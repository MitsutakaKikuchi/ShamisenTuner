React Native（Expo）とSwiftネイティブモジュールを組み合わせた、三味線調弦アプリの詳細設計書を作成しました。

実装においてご指定いただいた「早期リターン」「index不使用」「オブジェクト単位のデータハンドリング」の原則、および「3本の絃を中央に配置する美しい構図」のUI設計思想を組み込んでいます。

---

# 三味線調弦アプリ 詳細設計書

## 1. コンポーネント・アーキテクチャ設計

UIを単一の `App.tsx` に記述するのではなく、機能ごとに責務を分割します（今回は概念としての分割であり、実際のファイル構成はプロジェクト規模に応じます）。

* **`App` (Main Container)**: アプリ全体のレイアウト構成とグローバルな状態管理。
* **`BackgroundStrings`**: 画面中央に3本の絃を配置する装飾コンポーネント。UIの美しさと一体感を担う。
* **`CalibrationControl`**: 基準ピッチ（440Hzなど）の増減UI。
* **`BasePitchPicker`**: 一の糸の基音（A3〜A4）を選択するドラムロールUI。
* **`FineTuneSlider`**: 1/4音単位の微調整UI。
* **`TuningModeSelector`**: 本調子・二上り・三下りの選択UI。
* **`AutoPlayToggle`**: アルペジオ自動再生のON/OFFスイッチ。
* **`StringPlayButtons`**: 各糸（一の糸、二の糸、三の糸）の個別再生ボタン。



## 2. 状態管理（State）データ構造設計

Reactの `useState`（またはカスタムフック）で管理するアプリのコアデータです。

```typescript
// 管理する主な状態（State）
type AppState = {
  calibrationHz: number;      // 基準ピッチ (例: 440)
  baseNoteId: string;         // 選択中の基音ID (例: 'note_4' -> C)
  fineTuneCents: number;      // 微調整のセント値 (例: 50 = +1/4音)
  tuningModeId: string;       // 選択中の調弦モード (例: 'honchoshi')
  isAutoPlaying: boolean;     // 自動再生の状態
  activeStringId: string | null; // 現在発音中の糸のID (視覚的ハイライト用)
};

```

## 3. 音高（周波数）計算ロジック詳細

本アプリの要となる、基準ピッチから各糸の周波数（Hz）を算出する数学的ロジックです。

### 3.1 一の糸（基音）の算出

選択した音階（平均律）と微調整（セント）から、一の糸の周波数  を算出します。
基準ピッチ（A4）の周波数を 、A4からの半音の距離を （下がる場合はマイナス）、微調整のセント値を （1半音 = 100セント。1/4音なら50）とします。

### 3.2 二の糸・三の糸の算出（純正律）

一の糸の周波数  を基準として、純正律の単純な整数比を用いて掛け算を行います。

* **本調子**
* 二の糸:  (完全4度)
* 三の糸:  (完全8度/オクターブ)


* **二上り**
* 二の糸:  (完全5度)
* 三の糸:  (完全8度)


* **三下り**
* 二の糸:  (完全4度)
* 三の糸:  (短7度)



## 4. ネイティブモジュール連携（I/O）設計

TypeScript側とSwift側（`ShamisenAudio`）の境界となるAPI設計です。

| 関数名 | 引数 | 戻り値 | 役割 |
| --- | --- | --- | --- |
| `playTone` | `frequency: number` (Hz) | `void` | 指定した周波数の正弦波をフェードイン再生する。既に鳴っている場合は滑らかに周波数を移行する。 |
| `stopTone` | なし | `void` | 現在鳴っている音をフェードアウトして停止する。 |

*※「等ラウドネス曲線」を考慮した音量補正が必要な場合、将来的に `playTone(frequency: number, volume: number)` のように引数を拡張できるように設計しておきます。*

## 5. 主要な処理フロー（振る舞い）仕様

### 5.1 早期リターンを適用した発音制御

ボタン押下時のイベントハンドラは、無効な状態を早期に弾く（Early Return）ことでネストを浅く保ちます。

```typescript
const handleStringPress = (stringData: StringObj) => {
  // 1. 無効なデータの場合は早期リターン
  if (!stringData) return;
  
  // 2. 自動再生中は手動操作をブロック（早期リターン）
  if (isAutoPlaying) return;

  // 3. 周波数を計算
  const frequency = calculateFrequency(stringData.id, baseNoteId, tuningModeId, calibrationHz, fineTuneCents);
  
  // 4. 計算に失敗した場合は早期リターン
  if (!frequency || frequency <= 0) return;

  // 5. ネイティブモジュール呼び出しとUI状態更新
  playTone(frequency);
  setActiveStringId(stringData.id);
};

```

### 5.2 自動再生（アルペジオ）のループ制御

* `isAutoPlaying` が `true` になった際、Reactの `useEffect` またはカスタムフック内で `setInterval` を起動します。
* 配列オブジェクト（一の糸、二の糸、三の糸）を順に参照し、約1〜1.5秒間隔で `playTone` を呼び出します。
* `isAutoPlaying` が `false` に切り替わった瞬間に `clearInterval` を実行し、同時に `stopTone()` を呼び出して音を止めます。

---

この詳細設計に基づき、TypeScript側で「3. 音高計算ロジック詳細」を実装する計算関数（`calculateFrequency`）や、自動再生を制御する「カスタムフック」のコードを作成いたしましょうか？